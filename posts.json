[
    {
        "id": "2011-01-17-Integrating_a_SproutCore_client_in_a_deployable_war_file",
        "postTitle": "Integrating a Sproutcore client in a deployable .WAR file",
        "postDate": "2011-01-17",
        "postShortIntro": "Integrating SproutCore with a Java Deployable",
        "postLongIntro": "EurekaJ Profiler (http://eurekaj.haagen.name) has a frontent SproutCore (SC) client application that talks to a backend Java application. The Java backend is deployed as a .WAR file and in this particular setting, I wanted to be able to package the Sproutcore application inside the .WAR file for a single deployable.",
        "postFilename": "2011-01-17-Integrating_a_SproutCore_client_in_a_deployable_war_file.md"
    },
    {
        "id": "2011-01-25-Implementing_the_eurekaj_statechart",
        "postTitle": "Implementing the EurekaJ Statechart in SproutCore",
        "postDate": "2011-01-25",
        "postShortIntro": "Implementing StateCharts in SproutCore",
        "postLongIntro": "Have you ever been frustrated about the number of code lines that you have in you Model-View-Controller application (MVC) for managing the current state of the application ? Is determining the overall state of the application hard to figure out, and generally a mess to debug ? Does your GUI tend to show the wrong panels, have overlapping panels and in general have recurring bugs with its state ? Then Statecharts are the way to go to achieve a cleaner, testable and less error-prone GUI.",
        "postFilename": "2011-01-25-Implementing_the_eurekaj_statechart.md"
    },
    {
        "id": "2011-01-27-Customizing_the_SproutCore_TreeController",
        "postTitle": "Customizing the SproutCore TreeController",
        "postDate": "2011-01-27",
        "postShortIntro": "Customizing the SproutCore TreeController with a custom view",
        "postLongIntro": "In the SproutCore client I wanted to display a customized icon for the leaf nodes, depending on the type of node. Each node has a “nodeType” parameter that can either be “chart”, “alert” og “groupedStatistic”, and I wanted to display a custom icon for each of the different nodes.",
        "postFilename": "2011-01-27-Customizing_the_SproutCore_TreeController.md"
    },
    {
        "id": "2011-05-17-Moving_the_profiling_into_the_cloud",
        "postTitle": "Moving your profiling to the Cloud",
        "postDate": "2011-05-17",
        "postShortIntro": "Moving your Profiling merics into the Cloud",
        "postLongIntro": "During the last couple of years I have been working on an application (EurekaJ – Currently in beta. Final release expected in August 2011) that makes it possible to visualize and alert upon metrics generated by a profiling agent for the JVM. ",
        "postFilename": "2011-05-17-Moving_the_profiling_into_the_cloud.md"
    },
    {
        "id": "2011-05-24-The_RIA_MVC_Model",
        "postTitle": "The Client-side Rich Internet Application MVC model",
        "postDate": "2011-05-17",
        "postShortIntro": "Explaining the Client-side MVC model and how it differs from the server-side MVC model",
        "postLongIntro": "We have had a number of very good server-side frameworks for building Web 2.0 Internet applications for a number of years, and they all helped spike the AJAX “revolution” for the Web. AJAX finally gave us a genuine dynamic feel to the Web, which was a very welcomed change for the users. However, everything still felt a lot like Web 1.0 on the server side, which there are two main reasons for.",
        "postFilename": "2011-05-24-The_RIA_MVC_Model.md"
    },
    {
        "id": "2012-05-05-Ember_tree",
        "postTitle": "Implementing a Custom Tree Model in Ember",
        "postDate": "2012-05-05",
        "postShortIntro": "Explaining the Client-side MVC model and how it differs from the server-side MVC model",
        "postLongIntro": "We have had a number of very good server-side frameworks for building Web 2.0 Internet applications for a number of years, and they all helped spike the AJAX “revolution” for the Web. AJAX finally gave us a genuine dynamic feel to the Web, which was a very welcomed change for the users. However, everything still felt a lot like Web 1.0 on the server side, which there are two main reasons for.",
        "postFilename": "2012-05-05-Ember_tree.md"
    },
    {
        "id": "2012-05-14-when_did_agile_swallow_pragmatic",
        "postTitle": "When Did Agile Swallow Pragmatic ?",
        "postDate": "2012-05-14",
        "postShortIntro": "My question, is simply this: When did Agile grow into a behemoth that swallowed the ability to be pragmatic in an Agile Team? ",
        "postLongIntro": "The Agile train have arrived and it has taken over from it waterfall cousin. My question, though, is simply this: When did Agile grow into a behemoth that swallowed the ability to be pragmatic in an Agile Team?",
        "postFilename": "2012-05-14-When_did_agile_swallow_pragmatic.md"
    },
    {
        "id": "2012-09-03-Combining_Ember_js_with_Netty",
        "postTitle": "Combining Ember.js with Netty",
        "postDate": "2012-09-03",
        "postShortIntro": "Combining Ember.js with Netty ",
        "postLongIntro": "This blog post is split up into three parts. The first part consists of a short introduction, while the second and third part will talk about the client-side and the server-side respectably. The last part will also talk about one way in which it is possible to utilize the server-side application in order to keep your development, test and production versions of your client-side app the same without needing the prepackage the JavaScript code.",
        "postFilename": "2012-09-03-Combining_Ember_js_with_Netty.md"
    }
]