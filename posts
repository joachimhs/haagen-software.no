{
    "posts": [
        {
            "id": "2011-01-17-Integrating_a_SproutCore_client_in_a_deployable_war_file",
            "post_title": "Integrating a Sproutcore client in a deployable .WAR file",
            "post_date": "2011-01-17",
            "post_short_intro": "Integrating SproutCore with a Java Deployable",
            "post_long_intro": "EurekaJ Profiler (http://eurekaj.haagen.name) has a frontent SproutCore (SC) client application that talks to a backend Java application. The Java backend is deployed as a .WAR file and in this particular setting, I wanted to be able to package the Sproutcore application inside the .WAR file for a single deployable.",
            "post_filename": "2011-01-17-Integrating_a_SproutCore_client_in_a_deployable_war_file.md"
        },
        {
            "id": "2011-01-25-Implementing_the_eurekaj_statechart",
            "post_title": "Implementing the EurekaJ Statechart in SproutCore",
            "post_date": "2011-01-25",
            "post_short_intro": "Implementing StateCharts in SproutCore",
            "post_long_intro": "Have you ever been frustrated about the number of code lines that you have in you Model-View-Controller application (MVC) for managing the current state of the application ? Is determining the overall state of the application hard to figure out, and generally a mess to debug ? Does your GUI tend to show the wrong panels, have overlapping panels and in general have recurring bugs with its state ? Then Statecharts are the way to go to achieve a cleaner, testable and less error-prone GUI.",
            "post_filename": "2011-01-25-Implementing_the_eurekaj_statechart.md"
        },
        {
            "id": "2011-01-27-Customizing_the_SproutCore_TreeController",
            "post_title": "Customizing the SproutCore TreeController",
            "post_date": "2011-01-27",
            "post_short_intro": "Customizing the SproutCore TreeController with a custom view",
            "post_long_intro": "In the SproutCore client I wanted to display a customized icon for the leaf nodes, depending on the type of node. Each node has a “nodeType” parameter that can either be “chart”, “alert” og “groupedStatistic”, and I wanted to display a custom icon for each of the different nodes.",
            "post_filename": "2011-01-27-Customizing_the_SproutCore_TreeController.md"
        },
        {
            "id": "2011-05-17-Moving_the_profiling_into_the_cloud",
            "post_title": "Moving your profiling to the Cloud",
            "post_date": "2011-05-17",
            "post_short_intro": "Moving your Profiling merics into the Cloud",
            "post_long_intro": "During the last couple of years I have been working on an application (EurekaJ – Currently in beta. Final release expected in August 2011) that makes it possible to visualize and alert upon metrics generated by a profiling agent for the JVM. ",
            "post_filename": "2011-05-17-Moving_the_profiling_into_the_cloud.md"
        },
        {
            "id": "2011-05-24-The_RIA_MVC_Model",
            "post_title": "The Client-side Rich Internet Application MVC model",
            "post_date": "2011-05-17",
            "post_short_intro": "Explaining the Client-side MVC model and how it differs from the server-side MVC model",
            "post_long_intro": "We have had a number of very good server-side frameworks for building Web 2.0 Internet applications for a number of years, and they all helped spike the AJAX “revolution” for the Web. AJAX finally gave us a genuine dynamic feel to the Web, which was a very welcomed change for the users. However, everything still felt a lot like Web 1.0 on the server side, which there are two main reasons for.",
            "post_filename": "2011-05-24-The_RIA_MVC_Model.md"
        },
        {
            "id": "2012-05-05-Ember_tree",
            "post_title": "Implementing a Custom Tree Model in Ember",
            "post_date": "2012-05-05",
            "post_short_intro": "Explaining the Client-side MVC model and how it differs from the server-side MVC model",
            "post_long_intro": "We have had a number of very good server-side frameworks for building Web 2.0 Internet applications for a number of years, and they all helped spike the AJAX “revolution” for the Web. AJAX finally gave us a genuine dynamic feel to the Web, which was a very welcomed change for the users. However, everything still felt a lot like Web 1.0 on the server side, which there are two main reasons for.",
            "post_filename": "2012-05-05-Ember_tree.md"
        },
        {
            "id": "2012-05-14-when_did_agile_swallow_pragmatic",
            "post_title": "When Did Agile Swallow Pragmatic ?",
            "post_date": "2012-05-14",
            "post_short_intro": "My question, is simply this: When did Agile grow into a behemoth that swallowed the ability to be pragmatic in an Agile Team? ",
            "post_long_intro": "The Agile train have arrived and it has taken over from it waterfall cousin. My question, though, is simply this: When did Agile grow into a behemoth that swallowed the ability to be pragmatic in an Agile Team?",
            "post_filename": "2012-05-14-When_did_agile_swallow_pragmatic.md"
        },
        {
            "id": "2012-09-03-Combining_Ember_js_with_Netty",
            "post_title": "Combining Ember.js with Netty",
            "post_date": "2012-09-03",
            "post_short_intro": "Combining Ember.js with Netty ",
            "post_long_intro": "This blog post is split up into three parts. The first part consists of a short introduction, while the second and third part will talk about the client-side and the server-side respectably. The last part will also talk about one way in which it is possible to utilize the server-side application in order to keep your development, test and production versions of your client-side app the same without needing the prepackage the JavaScript code.",
            "post_filename": "2012-09-03-Combining_Ember_js_with_Netty.md"
        }
    ]
}